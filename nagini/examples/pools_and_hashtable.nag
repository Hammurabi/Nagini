# Nagini Pool Allocators and Hash Table Object Example
# Demonstrates DynamicPool, StaticPool, and hash table based Object structure

# All objects now use hash tables for members
# Members are accessed via symbol IDs: object[member_symbol]

# Example using default GC strategy (uses DynamicPool by default)
class GameObject(Object):
    id: int
    position_x: float
    position_y: float
    health: int

# Using StaticPool strategy (fixed size, throws error when full)
@property(malloc_strategy='pool', layout='cpp', paradigm='object')
class Bullet(Object):
    x: float
    y: float
    velocity: float

# Data paradigm - no hash table, direct struct access
@property(malloc_strategy='heap', layout='cpp', paradigm='data')
class Vector3D:
    x: float
    y: float
    z: float

# Key Features Demonstrated:
# 
# 1. Object Structure:
#    struct Object {
#        HashTable* hash_table;  // Contains all members
#        int64_t __refcount__;   // Reference counter
#    }
#
# 2. Member Access:
#    - Member names convert to integers via global symbol table
#    - Access: object[member_symbol] -> hash_table lookup
#
# 3. Memory Pools:
#    - DynamicPool: auto-resizes (default for primitives and gc strategy)
#    - StaticPool: fixed size, throws error when full (pool strategy)
#
# 4. Lists are lists of Objects:
#    - Any object type can be inside a list
#    - Lists use hash table structure like all objects
